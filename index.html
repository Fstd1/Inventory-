<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory Management App</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            padding: 20px;
            background-color: #f8f9fa;
            font-size: 0.9rem; /* Base font size for the body */
        }
        .card {
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .form-section {
            padding: 20px;
        }
        .table-container {
            max-height: 500px;
            overflow-y: auto;
        }
        .table th {
            position: sticky;
            top: 0;
            background-color: #f8f9fa;
            z-index: 1;
            font-size: 0.85rem;
        }
        .table td {
            font-size: 0.85rem;
        }
        #userId, #dbStatus {
            font-weight: bold;
        }
        /* Custom styles for Bootstrap form elements and buttons */
        .form-control, .form-select, .btn {
            border-radius: 6px;
        }
        .btn-primary {
            background-color: #007bff;
            border-color: #007bff;
        }
        .btn-primary:hover {
            background-color: #0056b3;
            border-color: #0056b3;
        }
        .btn-warning {
            background-color: #ffc107;
            border-color: #ffc107;
            color: #333;
        }
        .btn-warning:hover {
            background-color: #e0a800;
            border-color: #e0a800;
        }
        .btn-danger {
            background-color: #dc3545;
            border-color: #dc3545;
        }
        .btn-danger:hover {
            background-color: #c82333;
            border-color: #c82333;
        }

        .compact-card {
        }
        .compact-card .form-label,
        .compact-card .form-control,
        .compact-card .form-select,
        .compact-card .btn {
            font-size: 0.85rem;
        }
        .compact-card .card-header h3 {
            font-size: 1.2rem;
        }
        .arrival-edit-row {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
        }
        /* Styles for login form */
        #appContent {
            display: none; /* Hidden until authenticated */
        }
        #loginContainer {
            max-width: 400px;
            margin: 50px auto;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            background-color: #fff;
        }
        .login-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .login-status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .login-status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-4">Inventory Management App</h1>

        <!-- Login Container -->
        <div id="loginContainer" class="card">
            <div class="card-header">
                <h3>Login to Inventory App</h3>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="loginEmail" class="form-label">Email address:</label>
                    <input type="email" class="form-control" id="loginEmail" placeholder="name@example.com">
                </div>
                <div class="mb-3">
                    <label for="loginPassword" class="form-label">Password:</label>
                    <input type="password" class="form-control" id="loginPassword" placeholder="Password">
                </div>
                <button type="button" class="btn btn-primary w-100 mb-3" id="loginBtn">Login</button>
                <div id="loginStatus" class="login-status info">Please enter your credentials.</div>
            </div>
        </div>

        <!-- Main App Content (hidden until login) -->
        <div id="appContent">
            <div class="card">
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6"><p>User ID: <span id="userId">Loading...</span></p></div>
                        <div class="col-md-6"><p>Database Status: <span id="dbStatus">Connected (Firebase Firestore)</span></p></div>
                    </div>
                    <button type="button" class="btn btn-secondary mt-3" id="logoutBtn">Logout</button>

                    <!-- ADD MIGRATION BUTTON HERE -->
                    <div class="mt-3">
                        <button type="button" class="btn btn-info" id="migrateDataBtn">Migrate Old Data to Shared Collection</button>
                        <p id="migrationStatus" class="mt-2 text-info"></p>
                    </div>
                    <!-- END MIGRATION BUTTON -->

                </div>
            </div>

            <div class="row">
                <div class="col-md-6 col-12">
                    <div class="card compact-card">
                        <div class="card-header">
                            <h3>Add New Inventory Entry</h3>
                        </div>
                        <div class="card-body form-section">
                            <form id="inventoryForm">
                                <div class="mb-3">
                                    <label for="agentSelect" class="form-label">Agent:</label>
                                    <div class="input-group">
                                        <select class="form-select" id="agentSelect">
                                            <option value="">Select Existing Agent</option>
                                        </select>
                                        <input type="text" class="form-control" id="newAgentInput" placeholder="Enter New Agent" style="display:none;">
                                        <div class="input-group-text">
                                            <input class="form-check-input mt-0" type="checkbox" id="addNewAgentCheckbox" aria-label="Checkbox for new agent"> Add New
                                        </div>
                                    </div>
                                </div>

                                <div class="mb-3">
                                    <label for="partySelect" class="form-label">Party:</label>
                                    <div class="input-group">
                                        <select class="form-select" id="partySelect">
                                            <option value="">Select Existing Party</option>
                                        </select>
                                        <input type="text" class="form-control" id="newPartyInput" placeholder="Enter New Party" style="display:none;">
                                        <div class="input-group-text">
                                            <input class="form-check-input mt-0" type="checkbox" id="addNewPartyCheckbox" aria-label="Checkbox for new party"> Add New
                                        </div>
                                    </div>
                                </div>

                                <div class="mb-3">
                                    <label for="item" class="form-label">Item:</label>
                                    <input type="text" class="form-control" id="item" list="itemSuggestions">
                                    <datalist id="itemSuggestions"></datalist>
                                </div>

                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label for="permitDate" class="form-label">Permit Approved Date (DD/MM/YYYY):</label>
                                        <input type="text" class="form-control" id="permitDate" placeholder="DD/MM/YYYY">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="approvedQty" class="form-label">Approved Quantity (kg):</label>
                                        <input type="number" class="form-control" id="approvedQty" min="0" step="0.01">
                                    </div>
                                </div>

                                <!-- Container for editing existing arrivals -->
                                <div id="arrivalsEditContainer" class="mb-3" style="display:none;">
                                    <!-- Editable arrivals will be injected here by JavaScript -->
                                </div>


                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label for="arrivedQty" class="form-label">Arrived Quantity (kg) (New Receipt):</label>
                                        <input type="number" class="form-control" id="arrivedQty" min="0" step="0.01">
                                    </div>
                                    <div class="col-md-6">
                                        <label for="receivedDate" class="form-label">Received Date (DD/MM/YYYY) (New Receipt):</label>
                                        <input type="text" class="form-control" id="receivedDate" placeholder="DD/MM/YYYY">
                                    </div>
                                </div>

                                <div class="d-flex gap-2">
                                    <button type="submit" class="btn btn-primary">Add / Update Entry</button>
                                    <button type="button" class="btn btn-secondary" id="cancelEdit">Cancel Edit</button>
                                    <button type="button" class="btn btn-secondary" id="clearForm">Clear Form</button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>

                <div class="col-md-6 col-12">
                    <div class="card compact-card">
                        <div class="card-header">
                            <h3>Import Data from CSV</h3>
                        </div>
                        <div class="card-body form-section">
                            <form id="importForm">
                                <div class="mb-3">
                                    <label for="csvFile" class="form-label">Choose CSV File:</label>
                                    <input type="file" class="form-control" id="csvFile" accept=".csv" required>
                                </div>
                                <button type="submit" class="btn btn-primary">Import CSV Data</button>
                                 <div id="importStatus" class="mt-3 text-success fw-bold"></div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <h3>View and Download Data</h3>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label for="filterAgent" class="form-label">Filter by Agent:</label>
                        <select class="form-select" id="filterAgent">
                            <option value="">All Agents</option>
                        </select>
                    </div>

                    <div class="d-flex gap-2 mb-3">
                        <button class="btn btn-primary" id="downloadAll">Download All Data</button>
                        <button class="btn btn-primary" id="downloadFiltered">Download Filtered Data</button>
                    </div>

                    <div class="table-container">
                        <table class="table table-striped">
                            <thead>
                                <tr>
                                    <th>Agent</th>
                                    <th>Party</th>
                                    <th>Item</th>
                                    <th>Permit Date</th>
                                    <th>Approved Qty (kg)</th>
                                    <th>Arrivals</th>
                                    <th>Remaining Qty (kg)</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="inventoryTable">
                                <tr><td colspan="8">Loading inventory data...</td></tr>
                                <!-- Data will be loaded here -->
                            </tbody>
                            <tfoot id="inventoryTableFooter">
                                <!-- Totals will be displayed here -->
                            </tfoot>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Confirmation Modal HTML -->
    <div class="modal fade" id="customConfirmModal" tabindex="-1" aria-labelledby="customConfirmModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="customConfirmModalLabel">Confirmation</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="customConfirmModalBody">
                    Are you sure?
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="customConfirmOkBtn">OK</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast for brief messages -->
    <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
      <div id="liveToast" class="toast hide" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
          <strong class="me-auto">Notification</strong>
          <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body" id="toastBody">
          Hello, world! This is a toast message.
        </div>
      </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
    <script type="module">
        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyBFDelA8LUuun1FJtMJm9Rho9DcMnC-tFM",
            authDomain: "permit-e7178.firebaseapp.com",
            projectId: "permit-e7178",
            storageBucket: "permit-e7178.firebasestorage.app",
            messagingSenderId: "164064780119",
            appId: "1:164064780119:web:b4a0c380dddbb93737a812",
            measurementId: "G-EVQ8XS554G"
        };

        // --- Firebase SDK Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, onSnapshot, doc, setDoc, deleteDoc, addDoc, getDocs, where, updateDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global Variables ---
        let app;
        let db;
        let auth;
        let currentUserId = null; // Will be set by Firebase auth state, but NOT used in shared data path
        let firestoreCollectionRef; 

        const appId = firebaseConfig.projectId; // Ensures appId is always the project ID
        const firebaseConfigFromGlobal = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : firebaseConfig;

        let inventoryData = [];
        let agents = new Set();
        let parties = new Set();
        let editIndex = -1; 
        let confirmCallback = null;

        // Get Toast element
        const liveToast = document.getElementById('liveToast');
        const toastBody = document.getElementById('toastBody');
        const toast = new bootstrap.Toast(liveToast, { autohide: true, delay: 3000 });

        /**
         * Displays a custom confirmation modal.
         * @param {string} message - The message to display in the modal.
         * @param {function} callback - The function to call if 'OK' is clicked.
         */
        function showCustomConfirm(message, callback) {
            document.getElementById('customConfirmModalBody').textContent = message;
            confirmCallback = callback;
            const confirmModal = new bootstrap.Modal(document.getElementById('customConfirmModal'));
            confirmModal.show();
        }

        /**
         * Displays a transient message using Bootstrap Toast.
         * @param {string} message - The message to display.
         * @param {boolean} isError - True if it's an error message (optional, defaults to false).
         */
        function showToast(message, isError = false) {
            toastBody.textContent = message;
            if (isError) {
                liveToast.classList.remove('text-bg-success');
                liveToast.classList.add('text-bg-danger');
            } else {
                liveToast.classList.remove('text-bg-danger');
                liveToast.classList.add('text-bg-success');
            }
            toast.show();
        }

        // Event listener for the custom confirmation modal's OK button
        document.getElementById('customConfirmOkBtn').addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback();
            }
            const confirmModal = bootstrap.Modal.getInstance(document.getElementById('customConfirmModal'));
            confirmModal.hide();
        });

        // Function to display login status messages
        function showLoginStatus(message, isError = false) {
            const loginStatusDiv = document.getElementById('loginStatus');
            loginStatusDiv.textContent = message;
            if (isError) {
                loginStatusDiv.classList.remove('info');
                loginStatusDiv.classList.add('error');
            } else {
                loginStatusDiv.classList.remove('error');
                loginStatusDiv.classList.add('info');
            }
        }

        /**
         * Handles user login with email and password.
         * @param {Event} e - The click event.
         */
        document.getElementById('loginBtn').addEventListener('click', async (e) => {
            e.preventDefault(); 
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                showLoginStatus("Please enter both email and password.", true);
                return;
            }

            showLoginStatus("Logging in...", false);
            try {
                await signInWithEmailAndPassword(auth, email, password);
                // onAuthStateChanged listener will handle UI update
            } catch (error) {
                console.error("Login Error:", error);
                let errorMessage = "Login failed. Please check your credentials.";
                if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Email/Password sign-in is not enabled in Firebase. Please enable it in the Firebase console.";
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                    errorMessage = "Invalid email or password.";
                } else if (error.code === 'auth/too-many-requests') {
                    errorMessage = "Too many login attempts. Please try again later.";
                }
                showLoginStatus(errorMessage, true);
            }
        });

        // Event listener for the logout button
        document.getElementById('logoutBtn').addEventListener('click', async () => {
            try {
                await signOut(auth);
                // onAuthStateChanged will handle hiding app content and showing login
            } catch (error) {
                console.error("Logout Error:", error);
                showCustomConfirm(`Logout failed: ${error.message}`, () => {});
            }
        });


        // Initialize Firebase and set up auth listener
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                app = initializeApp(firebaseConfigFromGlobal);
                db = getFirestore(app);
                auth = getAuth(app);

                // Listen for auth state changes - this is the main handler
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        currentUserId = user.uid; // Store the logged-in user's UID (for display), but not used in data path
                        document.getElementById('userId').textContent = currentUserId;
                        document.getElementById('dbStatus').textContent = 'Connected (Firebase Firestore)';
                        
                        document.getElementById('loginContainer').style.display = 'none';
                        document.getElementById('appContent').style.display = 'block';

                        setupFirestoreListener(); 
                        showLoginStatus("Logged in successfully.", false); 
                    } else {
                        currentUserId = null; 
                        document.getElementById('userId').textContent = 'Not Logged In';
                        document.getElementById('dbStatus').textContent = 'Disconnected';
                        
                        document.getElementById('loginContainer').style.display = 'block';
                        document.getElementById('appContent').style.display = 'none';
                        
                        inventoryData = []; 
                        updateTable(); 
                        showLoginStatus("Please log in to continue.", false);
                    }
                    document.getElementById('cancelEdit').style.display = 'none';
                });

                // Setup toggles for Agent and Party inputs (these can run independently of auth)
                const setupCheckboxToggle = (checkboxId, selectId, inputId) => {
                    const checkbox = document.getElementById(checkboxId);
                    const select = document.getElementById(selectId);
                    const input = document.getElementById(inputId);
                    
                    checkbox.addEventListener('change', () => {
                        const isChecked = checkbox.checked;
                        select.style.display = isChecked ? 'none' : 'block';
                        input.style.display = isChecked ? 'block' : 'none';
                        if (!isChecked) input.value = '';
                        if (checkboxId === 'addNewAgentCheckbox') {
                             populateSelects(isChecked ? '' : select.value);
                        }
                        updateItemSuggestions();
                    });
                };

                setupCheckboxToggle('addNewAgentCheckbox', 'agentSelect', 'newAgentInput');
                setupCheckboxToggle('addNewPartyCheckbox', 'partySelect', 'newPartyInput');
                
                document.getElementById('agentSelect').addEventListener('change', (e) => {
                    if (!document.getElementById('addNewAgentCheckbox').checked) {
                        populateSelects(e.target.value);
                    }
                    findAndFillPermit();
                    updateItemSuggestions();
                });
                
                document.getElementById('partySelect').addEventListener('change', () => {
                    findAndFillPermit();
                    updateItemSuggestions();
                });

                document.getElementById('item').addEventListener('input', findAndFillPermit);


                document.getElementById('clearForm').addEventListener('click', clearAndResetForm);

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                document.getElementById('dbStatus').textContent = `Connection Error: ${error.message}`;
            }
        });
        
        /**
         * Updates the datalist for item suggestions based on selected agent and party.
         */
        function updateItemSuggestions() {
            const agent = document.getElementById('addNewAgentCheckbox').checked ? document.getElementById('newAgentInput').value : document.getElementById('agentSelect').value;
            const party = document.getElementById('addNewPartyCheckbox').checked ? document.getElementById('newPartyInput').value : document.getElementById('partySelect').value;
            const suggestionsDatalist = document.getElementById('itemSuggestions');
            suggestionsDatalist.innerHTML = '';

            if (agent && party) {
                const items = new Set(
                    inventoryData
                        .filter(entry => entry.agent === agent && entry.party === party)
                        .map(entry => entry.item)
                );

                items.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item;
                    suggestionsDatalist.appendChild(option);
                });
            }
        }

        /**
         * Finds and fills permit details based on selected agent, party, and item.
         */
        function findAndFillPermit() {
            const agent = document.getElementById('addNewAgentCheckbox').checked ? document.getElementById('newAgentInput').value : document.getElementById('agentSelect').value;
            const party = document.getElementById('addNewPartyCheckbox').checked ? document.getElementById('newPartyInput').value : document.getElementById('partySelect').value;
            const item = document.getElementById('item').value;
            
            if (agent && party && item) {
                const existingPermit = inventoryData.find(entry => 
                    entry.agent === agent &&
                    entry.party === party &&
                    entry.item === item &&
                    (entry.remainingQty || 0) > 0
                );

                if (existingPermit) {
                    document.getElementById('permitDate').value = existingPermit.permitDate || '';
                    document.getElementById('approvedQty').value = existingPermit.approvedQty || 0;
                }
            }
        }

        /**
         * Sets up the Firestore listener to fetch and update inventory data in real-time.
         */
        function setupFirestoreListener() {
            // Ensure db is available before setting up listener
            if (!db) {
                console.error("Firestore DB not initialized for listener. Data will not be loaded.");
                return;
            }

            // Data path is now 'shared_inventory'
            const collectionPath = `artifacts/${appId}/shared_inventory`; 
            
            firestoreCollectionRef = collection(db, collectionPath);
            const q = query(firestoreCollectionRef); // Create a query against the collection

            // Listen for real-time updates to the collection
            onSnapshot(q, (snapshot) => {
                inventoryData = []; // Clear existing data
                agents.clear();    // Clear existing agents
                parties.clear();   // Clear existing parties

                // Populate inventoryData, agents, and parties from snapshot
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    inventoryData.push({ id: doc.id, ...data });
                    if (data.agent) agents.add(data.agent);
                    if (data.party) parties.add(data.party);
                });

                // Sort inventory data by Agent, then by Party
                inventoryData.sort((a, b) => {
                    const agentA = (a.agent || '').toLowerCase();
                    const agentB = (b.agent || '').toLowerCase();
                    const partyA = (a.party || '').toLowerCase();
                    const partyB = (b.party || '').toLowerCase();

                    if (agentA < agentB) return -1;
                    if (agentA > agentB) return 1;
                    
                    if (partyA < partyB) return -1;
                    if (partyA > partyB) return 1;

                    return 0; // Agents and Parties are the same
                });

                populateSelects(); // Update agent and party dropdowns
                updateTable(document.getElementById('filterAgent').value); // Re-render the table
            }, (error) => {
                console.error("Error fetching Firestore data:", error);
                document.getElementById('dbStatus').textContent = `Error: ${error.message}`;
            });
        }
        
        /**
         * Function to migrate data from the old default-app-id/users/UID path
         * to the new permit-e7178/shared_inventory path.
         * THIS IS A ONE-TIME MIGRATION SCRIPT. REMOVE AFTER USE.
         */
        async function migrateOldData() {
            if (!db || !auth.currentUser) {
                showCustomConfirm("Please log in before attempting data migration.", () => {});
                document.getElementById('migrationStatus').textContent = "Login required.";
                return;
            }

            showCustomConfirm("Starting data migration. This may take a moment. Do not close the browser.", async () => {
                document.getElementById('migrationStatus').textContent = "Migration in progress...";
                const oldAppId = 'default-app-id'; // The old appId used
                const oldUserIdForData = 'UO1TWhMChAbhqh1NOF5Xve8fPsr2'; // The specific UID under which old data was stored
                const oldCollectionPath = `artifacts/${oldAppId}/users/${oldUserIdForData}/inventory`;
                const newCollectionPath = `artifacts/${appId}/shared_inventory`; // The new shared path

                const oldCollectionRef = collection(db, oldCollectionPath);
                const newCollectionRef = collection(db, newCollectionPath);

                let migratedCount = 0;
                let errorCount = 0;
                const batch = writeBatch(db); // Use a batch for efficient writes

                try {
                    const querySnapshot = await getDocs(query(oldCollectionRef));

                    if (querySnapshot.empty) {
                        document.getElementById('migrationStatus').textContent = "No old data found to migrate.";
                        showCustomConfirm("No old data found at the specified path to migrate.", () => {});
                        return;
                    }

                    querySnapshot.forEach((oldDoc) => {
                        // Get data from old document, exclude the ID
                        const data = oldDoc.data();
                        
                        // Create a new document reference in the new shared collection
                        const newDocRef = doc(newCollectionRef); // Firestore will generate a new ID
                        
                        // Add the write operation to the batch
                        batch.set(newDocRef, data); // Set (create) the new document with old data
                        migratedCount++;

                        // Commit batch every 499 operations to stay within limit (Firestore limit is 500)
                        if (migratedCount % 499 === 0) {
                            batch.commit();
                            batch = writeBatch(db); // Start a new batch
                        }
                    });

                    // Commit any remaining operations in the last batch
                    await batch.commit(); 
                    
                    document.getElementById('migrationStatus').textContent = `Migration complete: ${migratedCount} documents migrated.`;
                    showCustomConfirm(`Data migration finished. ${migratedCount} documents moved. Please remove the migration script from your HTML and revert rules.`, () => {});
                } catch (error) {
                    console.error("Migration failed:", error);
                    document.getElementById('migrationStatus').textContent = `Migration failed: ${error.message}`;
                    showCustomConfirm(`Data migration failed: ${error.message}. Check console for details.`, () => {});
                    errorCount++;
                } finally {
                     // IMPORTANT: REMOVE OR COMMENT OUT THIS migrateOldData() FUNCTION
                     // AND THE migrateDataBtn BUTTON FROM YOUR HTML AFTER SUCCESSFUL MIGRATION.
                     // It is a one-time operation.
                }
            });
        }


        // Event listener for migration button
        document.getElementById('migrateDataBtn').addEventListener('click', migrateOldData);
        // END MIGRATION SCRIPT SECTION

        /**
         * Merges raw CSV data into a structured inventory format.
         * @param {Array<Object>} data - Raw data parsed from CSV.
         * @returns {Array<Object>} - Merged and structured inventory data.
         */
        function mergeData(data) {
            const merged = new Map(); 
            data.forEach(row => {
                if (!row["Agent"] || !row["Party"] || !row["Item"]) return;
                
                const permitDate = row["Permit Approved Date"] || '';
                const key = `${row["Agent"]}_${row["Party"]}_${row["Item"]}_${permitDate}`;
                const approvedQty = parseFloat(row["Approved Quantity"]) || 0;

                if (!merged.has(key)) {
                    merged.set(key, {
                        agent: row["Agent"],
                        party: row["Party"],
                        item: row["Item"],
                        permitDate: permitDate,
                        approvedQty: approvedQty,
                        arrivals: [], 
                    });
                }
                const entry = merged.get(key); 
                for (let i = 0; i < 5; i++) { 
                    const qtyKey = i === 0 ? "Arrived Quantity" : `Arrived Quantity_${i}`;
                    const dateKey = i === 0 ? "Received Date" : `Received Date_${i}`;
                    const arrivedQty = parseFloat(row[qtyKey]) || 0;
                    const receivedDate = row[dateKey];
                    if (arrivedQty > 0 && receivedDate) {
                        entry.arrivals.push({ quantity: arrivedQty, date: receivedDate });
                    }
                }
            });

            const finalData = Array.from(merged.values()); 
            finalData.forEach(entry => {
                const totalArrived = entry.arrivals.reduce((sum, a) => sum + a.quantity, 0);
                entry.remainingQty = entry.approvedQty - totalArrived;
            });

            return finalData;
        }

        /**
         * Populates the Agent and Party dropdowns based on current inventory data.
         * Optionally filters parties based on a selected agent.
         * @param {string} selectedAgentForPartyFilter - Optional agent to filter parties by.
         */
        function populateSelects(selectedAgentForPartyFilter = '') {
            const agentSelect = document.getElementById('agentSelect');
            const filterAgent = document.getElementById('filterAgent');
            const partySelect = document.getElementById('partySelect');

            const currentAgentFormSelection = agentSelect.value;
            const currentPartyFormSelection = partySelect.value;
            const currentFilterAgentSelection = filterAgent.value;

            const populateSelectWithOptions = (selectElement, options, defaultOptionText) => {
                selectElement.innerHTML = `<option value="">${defaultOptionText}</option>`; 
                options.forEach(optionValue => {
                    const option = document.createElement('option');
                    option.value = optionValue;
                    option.textContent = optionValue;
                    selectElement.appendChild(option);
                });
            };

            const sortedAgents = Array.from(agents).sort(); 
            populateSelectWithOptions(agentSelect, sortedAgents, "Select Existing Agent");
            populateSelectWithOptions(filterAgent, sortedAgents, "All Agents");

            let partiesToDisplay = selectedAgentForPartyFilter
                ? new Set(inventoryData.filter(item => item.agent === selectedAgentForPartyFilter).map(item => item.party))
                : parties;
            
            const sortedParties = Array.from(partiesToDisplay).sort((a,b) => a.toLowerCase().localeCompare(b.toLowerCase()));
            populateSelectWithOptions(partySelect, sortedParties, "Select Existing Party");

            agentSelect.value = currentAgentFormSelection;
            partySelect.value = currentPartyFormSelection;
            filterAgent.value = currentFilterAgentSelection;
        }
        
        /**
         * Updates the main inventory table with filtered or all data.
         * @param {string} agentFilter - Optional agent name to filter the table by.
         */
        function updateTable(agentFilter = '') {
            const tbody = document.getElementById('inventoryTable');
            const tfoot = document.getElementById('inventoryTableFooter');
            tbody.innerHTML = ''; 
            tfoot.innerHTML = ''; // Clear footer before recalculating

            const dataToRender = agentFilter ? inventoryData.filter(item => item.agent === agentFilter) : inventoryData;

            if (dataToRender.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8">No inventory data found.</td></tr>';
                return;
            }

            let totalArrivalRecords = 0;
            let totalQuantityReceived = 0;

            dataToRender.forEach((item) => {
                const arrivalsHtml = item.arrivals && item.arrivals.length > 0
                    ? item.arrivals.map(a => {
                        totalArrivalRecords++; // Count each individual arrival record
                        totalQuantityReceived += (a.quantity || 0); // Sum the quantity
                        return `${a.quantity}kg on ${a.date}`;
                    }).join('<br>')
                    : '-';

                const remainingQtyStyle = (item.remainingQty || 0) < 0 ? 'color: red; font-weight: bold;' : '';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${item.agent || ''}</td>
                    <td>${item.party || ''}</td>
                    <td>${item.item || ''}</td>
                    <td>${item.permitDate || ''}</td>
                    <td>${item.approvedQty || 0}</td>
                    <td>${arrivalsHtml}</td>
                    <td style="${remainingQtyStyle}">${item.remainingQty || 0}</td>
                    <td>
                        <button class="btn btn-sm btn-warning" onclick="window.editEntry('${item.id}')">Edit</button>
                        <button class="btn btn-sm btn-danger" onclick="window.deleteEntry('${item.id}')">Delete</button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            // Add totals to the table footer
            const totalsRow1 = document.createElement('tr');
            totalsRow1.innerHTML = `
                <th colspan="5" class="text-end">Total Arrival Records:</th>
                <th colspan="3">${totalArrivalRecords}</th>
            `;
            tfoot.appendChild(totalsRow1);

            const totalsRow2 = document.createElement('tr');
            totalsRow2.innerHTML = `
                <th colspan="5" class="text-end">Total Quantity Received:</th>
                <th colspan="3">${totalQuantityReceived.toFixed(2)} kg</th>
            `;
            tfoot.appendChild(totalsRow2);
        }
        
        // Event listener for the inventory form submission (Add/Update)
        document.getElementById('inventoryForm').addEventListener('submit', async (e) => {
            e.preventDefault(); 
            if (!firestoreCollectionRef) {
                showCustomConfirm("Database connection not ready. Please try again after logging in.", () => {});
                return;
            }

            const getFormValue = (checkboxId, inputId, selectId) => {
                const checkbox = document.getElementById(checkboxId);
                const input = document.getElementById(inputId);
                const select = document.getElementById(selectId);
                return checkbox.checked ? input.value : select.value;
            };

            const agent = getFormValue('addNewAgentCheckbox', 'newAgentInput', 'agentSelect');
            const party = getFormValue('addNewPartyCheckbox', 'newPartyInput', 'partySelect');
            const item = document.getElementById('item').value;
            const permitDate = document.getElementById('permitDate').value.trim();
            const approvedQty = parseFloat(document.getElementById('approvedQty').value) || 0;
            const newArrivedQty = parseFloat(document.getElementById('arrivedQty').value) || 0;
            const newReceivedDate = document.getElementById('receivedDate').value;

            if (!agent.trim() || !party.trim() || !item.trim()) {
                showCustomConfirm("Agent, Party, and Item cannot be empty.", () => {});
                return;
            }

            try {
                if (editIndex > -1) { 
                    const itemToUpdate = inventoryData[editIndex];
                    if (!itemToUpdate || !itemToUpdate.id) {
                        showCustomConfirm("Error: Item to update not found.", () => {});
                        return;
                    }
                    
                    let updatedArrivals = [];
                    document.querySelectorAll('.arrival-edit-row').forEach(row => {
                       const qty = parseFloat(row.querySelector('.arrival-qty-input').value) || 0;
                       const date = row.querySelector('.arrival-date-input').value;
                       if (qty > 0 && date) { 
                           updatedArrivals.push({ quantity: qty, date: date });
                       }
                    });

                    if (newArrivedQty > 0 && newReceivedDate) {
                        updatedArrivals.push({ quantity: newArrivedQty, date: newReceivedDate });
                    }
                    const totalArrived = updatedArrivals.reduce((sum, a) => sum + a.quantity, 0);

                    await setDoc(doc(firestoreCollectionRef, itemToUpdate.id), {
                        agent, party, item, permitDate, approvedQty,
                        arrivals: updatedArrivals,
                        remainingQty: approvedQty - totalArrived
                    });
                    showToast("Entry updated successfully!"); // Use toast for success

                } else { 
                    let q;
                    if (permitDate) {
                        q = query(firestoreCollectionRef, where("agent", "==", agent), where("party", "==", party), where("item", "==", item), where("permitDate", "==", permitDate));
                    } else {
                        q = query(firestoreCollectionRef, where("agent", "==", agent), where("party", "==", party), where("item", "==", item), where("permitDate", "==", "")); 
                    }
                    
                    const querySnapshot = await getDocs(q);

                    if (!querySnapshot.empty) { 
                        const docSnapshot = querySnapshot.docs[0];
                        const existingData = docSnapshot.data();
                        let updatedArrivals = [...(existingData.arrivals || [])];
                        
                        if (newArrivedQty > 0 && newReceivedDate) {
                            updatedArrivals.push({ quantity: newArrivedQty, date: newReceivedDate });
                        }
                        const totalArrived = updatedArrivals.reduce((sum, a) => sum + a.quantity, 0);
                        
                        await updateDoc(doc(firestoreCollectionRef, docSnapshot.id), {
                            approvedQty: permitDate ? approvedQty : (existingData.approvedQty || 0), 
                            arrivals: updatedArrivals,
                            remainingQty: (permitDate ? approvedQty : (existingData.approvedQty || 0)) - totalArrived
                        });
                        showToast("Existing entry updated with new arrival!"); // Use toast for success

                    } else { 
                        const newEntry = { 
                            agent, 
                            party, 
                            item, 
                            permitDate, 
                            approvedQty: permitDate ? approvedQty : 0, 
                            arrivals: [], 
                            remainingQty: 0 
                        };
                        if (newArrivedQty > 0 && newReceivedDate) {
                            newEntry.arrivals.push({ quantity: newArrivedQty, date: newReceivedDate });
                        }
                        const totalArrived = newEntry.arrivals.reduce((sum, a) => sum + a.quantity, 0);
                        newEntry.remainingQty = newEntry.approvedQty - totalArrived;
                        await addDoc(firestoreCollectionRef, newEntry); 
                        showToast("New entry added successfully!"); // Use toast for success
                    }
                }
                clearAndResetForm(); 
            } catch (e) {
                console.error("Error adding/updating document:", e);
                showCustomConfirm(`Error: ${e.message}`, () => {});
            }
        });

        // Event listener for importing CSV data
        document.getElementById('importForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const file = document.getElementById('csvFile').files[0];
            const importStatus = document.getElementById('importStatus');
            if (!file || !firestoreCollectionRef) {
                showCustomConfirm("Please select a CSV file and ensure you are logged in.", () => {});
                return;
            }

            importStatus.textContent = "Importing...";
            Papa.parse(file, {
                header: true, 
                skipEmptyLines: true, 
                transform: (value) => value ? value.trim() : '', 
                complete: async (results) => {
                    const importedData = mergeData(results.data); 
                    for (const newEntry of importedData) {
                        try {
                             let q;
                            if (newEntry.permitDate) {
                                q = query(firestoreCollectionRef, where("agent", "==", newEntry.agent), where("party", "==", newEntry.party), where("item", "==", newEntry.item), where("permitDate", "==", newEntry.permitDate));
                            } else {
                                q = query(firestoreCollectionRef, where("agent", "==", newEntry.agent), where("party", "==", newEntry.party), where("item", "==", newEntry.item), where("permitDate", "==", ""));
                            }
                            const querySnapshot = await getDocs(q);

                            if (!querySnapshot.empty) { 
                                const docSnapshot = querySnapshot.docs[0];
                                const existingData = docSnapshot.data();
                                let updatedArrivals = [...(existingData.arrivals || [])];
                                newEntry.arrivals.forEach(newArr => {
                                    if (!updatedArrivals.some(exArr => exArr.quantity === newArr.quantity && exArr.date === newArr.date)) {
                                        updatedArrivals.push(newArr);
                                    }
                                });
                                const totalArrived = updatedArrivals.reduce((sum, a) => sum + a.quantity, 0);
                                await updateDoc(doc(firestoreCollectionRef, docSnapshot.id), {
                                    approvedQty: newEntry.approvedQty,
                                    arrivals: updatedArrivals,
                                    remainingQty: newEntry.approvedQty - totalArrived
                                });
                            } else { 
                                await addDoc(firestoreCollectionRef, newEntry);
                            }
                        } catch (error) {
                            console.error("Error processing imported row:", newEntry, error);
                            showCustomConfirm(`Error processing row: ${JSON.stringify(newEntry)} - ${error.message}`, () => {});
                        }
                    }
                    importStatus.textContent = "Import complete!";
                    setTimeout(() => importStatus.textContent = '', 3000); 
                    document.getElementById('importForm').reset(); 
                },
                error: (err) => {
                    console.error('CSV parsing error:', err);
                    importStatus.textContent = "Error during import.";
                    showCustomConfirm(`CSV parsing error: ${err.message}`, () => {});
                }
            });
        });

        // Event listener for filtering table by agent
        document.getElementById('filterAgent').addEventListener('change', (e) => updateTable(e.target.value));

        /**
         * Fills the form with data of an existing inventory entry for editing.
         * @param {string} id - The Firestore document ID of the entry to edit.
         */
        window.editEntry = (id) => {
            const item = inventoryData.find(entry => entry.id === id);
            if (!item) {
                showCustomConfirm("Entry not found for editing.", () => {});
                return;
            }

            clearAndResetForm(); 

            document.getElementById('agentSelect').value = item.agent;
            populateSelects(item.agent); 
            document.getElementById('partySelect').value = item.party;
            document.getElementById('item').value = item.item;
            document.getElementById('permitDate').value = item.permitDate;
            document.getElementById('approvedQty').value = item.approvedQty;

            const arrivalsContainer = document.getElementById('arrivalsEditContainer');
            arrivalsContainer.innerHTML = '<h5>Edit Existing Arrivals</h5>';
            if (item.arrivals && item.arrivals.length > 0) {
                item.arrivals.forEach((arrival, index) => {
                    const arrivalRow = document.createElement('div');
                    arrivalRow.className = 'row g-3 align-items-center arrival-edit-row';
                    arrivalRow.innerHTML = `
                        <div class="col-auto">
                            <label class="form-label">Qty:</label>
                            <input type="number" step="0.01" class="form-control arrival-qty-input" value="${arrival.quantity}">
                        </div>
                        <div class="col-auto">
                           <label class="form-label">Date:</label>
                           <input type="text" class="form-control arrival-date-input" value="${arrival.date}" placeholder="DD/MM/YYYY">
                        </div>
                        <div class="col-auto align-self-end">
                            <button type="button" class="btn btn-sm btn-outline-danger" onclick="this.parentElement.parentElement.remove()">Delete</button>
                        </div>
                    `;
                    arrivalsContainer.appendChild(arrivalRow);
                });
            }
            arrivalsContainer.style.display = 'block'; 

            editIndex = inventoryData.findIndex(entry => entry.id === id); 
            document.getElementById('cancelEdit').style.display = 'inline-block'; 
            window.scrollTo(0, 0); 
        };

        /**
         * Deletes an inventory entry from Firestore.
         * @param {string} id - The Firestore document ID of the entry to delete.
         */
        window.deleteEntry = async (id) => { // Made async directly
            if (!firestoreCollectionRef) {
                showToast("Database connection not ready. Cannot delete.", true); // Use toast for error
                return;
            }
            try {
                await deleteDoc(doc(firestoreCollectionRef, id));
                showToast("Entry deleted successfully!"); // Use toast for success
            } catch (e) {
                console.error("Error removing document:", e);
                showToast(`Error deleting document: ${e.message}`, true); // Use toast for error
            }
        };

        // Event listener for the Cancel Edit button
        document.getElementById('cancelEdit').addEventListener('click', clearAndResetForm);

        /**
         * Clears and resets the inventory form, hides edit-related elements.
         */
        function clearAndResetForm() {
            document.getElementById('inventoryForm').reset(); 
            editIndex = -1; 
            document.getElementById('cancelEdit').style.display = 'none'; 
            document.getElementById('arrivalsEditContainer').style.display = 'none'; 
            document.getElementById('arrivalsEditContainer').innerHTML = ''; 

            const resetSelect = (checkboxId, inputId, selectId) => {
                document.getElementById(checkboxId).checked = false;
                document.getElementById(inputId).style.display = 'none';
                document.getElementById(selectId).style.display = 'block';
            };

            resetSelect('addNewAgentCheckbox', 'newAgentInput', 'agentSelect');
            resetSelect('addNewPartyCheckbox', 'newPartyInput', 'partySelect');
            
            populateSelects(); 
            updateItemSuggestions(); 
        }

        /**
         * Downloads inventory data as a CSV file.
         * @param {Array<Object>} data - The data to download.
         * @param {string} filename - The desired filename for the CSV.
         */
        function downloadCSV(data, filename) {
            const rows = data.map(item => {
                const arrivals = (item.arrivals || []).map(a => `${a.quantity}kg on ${a.date}`).join('; ');
                return [item.agent, item.party, item.item, item.permitDate, item.approvedQty, `"${arrivals}"`, item.remainingQty]
                    .map(field => {
                        const str = String(field || '');
                        return str.includes(',') || str.includes('"') ? `"${str.replace(/"/g, '""')}"` : str;
                    }).join(','); 
            });
            const csvString = ['Agent,Party,Item,Permit Date,Approved Qty,Arrivals,Remaining Qty'].concat(rows).join('\n');
            
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
        }

        // Event listeners for download buttons
        document.getElementById('downloadAll').addEventListener('click', () => downloadCSV(inventoryData, 'inventory_all.csv'));
        document.getElementById('downloadFiltered').addEventListener('click', () => {
            const agentFilter = document.getElementById('filterAgent').value;
            const filteredData = agentFilter ? inventoryData.filter(item => item.agent === agentFilter) : inventoryData;
            downloadCSV(filteredData, `inventory_filtered_${agentFilter || 'all'}.csv`);
        });
    </script>
</body>
</html>
